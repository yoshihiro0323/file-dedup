package main

import (
	"encoding/csv"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
)

// FileGroup contains a file to keep and files to be removed
type FileGroup struct {
	keep     string   // file to keep
	removals []string // files to be removed
}

// createFileGroup applies sorting algorithm to generate FileGroup
func createFileGroup(files []string) FileGroup {
	// Function to determine if a filename is auto-generated by camera
	isAutoGenerated := func(filename string) bool {
		base := filepath.Base(filename)
		patterns := []string{"DSC", "IMG"}
		for _, pattern := range patterns {
			if len(base) >= len(pattern) && base[:len(pattern)] == pattern {
				return true
			}
		}
		return false
	}

	// Sort files:
	// 1. Auto-generated filenames go to the back
	// 2. Within same category, sort by filename length
	sort.Slice(files, func(i, j int) bool {
		iAuto := isAutoGenerated(files[i])
		jAuto := isAutoGenerated(files[j])

		if iAuto != jAuto {
			return jAuto // Move auto-generated files to the back
		}

		// Within same category, sort by filename length
		return len(files[i]) < len(files[j])
	})

	return FileGroup{
		keep:     files[0],
		removals: files[1:],
	}
}

func main() {
	// Get CSV file path from command line arguments
	csvPath := flag.String("csv", "", "Path to CSV file for duplicate check")
	outputPath := flag.String("out", "duplicates.txt", "Path to output text file")
	debugMode := flag.Bool("debug", false, "Debug mode (detailed output)")
	flag.Parse()

	if *csvPath == "" {
		log.Fatal("Please specify the CSV file path")
	}

	// Open CSV file
	file, err := os.Open(*csvPath)
	if err != nil {
		log.Fatalf("Failed to open CSV file: %v", err)
	}
	defer file.Close()

	csvDir := filepath.Dir(*csvPath)
	outputFullPath := filepath.Join(csvDir, *outputPath)

	r := csv.NewReader(file)
	// Assuming CSV file has no header
	records, err := r.ReadAll()
	if err != nil {
		log.Fatalf("Failed to read CSV: %v", err)
	}

	// Create a map with SHA256 hash as key and slice of corresponding filenames as value
	hashMap := make(map[string][]string)
	for _, rec := range records {
		if len(rec) < 2 {
			continue
		}
		filename := rec[0]
		hash := rec[1]
		hashMap[hash] = append(hashMap[hash], filename)
	}

	// Write results to output file
	outFile, err := os.Create(outputFullPath)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer outFile.Close()

	// Process duplicate file groups
	for _, files := range hashMap {
		if len(files) > 1 {
			group := createFileGroup(files)

			if *debugMode {
				// Debug mode: detailed output
				fmt.Fprintf(outFile, "File to keep: %s\n", group.keep)
				fmt.Fprintln(outFile, "Files to remove:")
				for _, f := range group.removals {
					fmt.Fprintf(outFile, "  %s\n", f)
				}
				fmt.Fprintln(outFile, "---")
			} else {
				// Normal mode: output only files to remove
				for _, f := range group.removals {
					fmt.Fprintln(outFile, f)
				}
			}
		}
	}

	fmt.Printf("Saved duplicate file list to %s\n", outputFullPath)
}
